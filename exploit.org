* compiling a 32 bit binary on a 64 bit machine
sudo apt-get install gcc-multilib
* frame pointer and stack pointer
The main difference is that, during the lifetime of a function, the stack
pointer can change (for eg in x86 arguments to functions are passed onto the
stack via push instructions which updates the stack pointer) whereas the frame
pointer doesn't change during the lifetime of a function. For eg in x86 local
variables are accessed using ebp (frame pointer) as the base address and an
offset which is determined at compile time. Since the frame pointer is fixed for
the lifetime of a function, it can be used to access local variables at any
point in the lifetime of the function.
* Why is this shellcode causing a segmentation fault?

#include <stdio.h>
#include <string.h>

# got to be const char
char code[] = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05";

int main()
{
    printf("len:%d bytes\n", strlen(code));
    (*(void(*)()) code)();
    return 0;
}

Writeable data in static storage (such as your code array) usually ends up in
the .data section which is usually marked “not executable.” Mark the array as
const so it ends up in .rodata resp. .text and can be executed.
* x command
(gdb) x/8bd &d2
0x7fffffffdf80: -80     16      64      0       0       0       0       0

(gdb) x/8b &d2
0x7fffffffdf80: 0xb0    0x10    0x40    0x00    0x00    0x00    0x00    0x00

(gdb) x/8w &d2
0x7fffffffdf80: 0x004010b0      0x00000000      0x44444444      0x55555555
0x7fffffffdf90: 0x00400fa0      0x00000000      0x00400950      0x00000000

(gdb) p pvtd2[1]
$18 = (long *) 0x5555555544444444

(gdb) p ((long)pvtd2[1] & 0xffffffff)
$19 = 1145324612

(gdb) p/x ((long)pvtd2[1] & 0xffffffff)
$20 = 0x44444444


x [Address expression]
x /[Format] [Address expression]
x /[Length][Format] [Address expression]
x
...........
o - octal
x - hexadecimal
d - decimal
u - unsigned decimal
t - binary
f - floating point
a - address
c - char
s - string
i - instruction
The following size modifiers are supported:

b - byte
h - halfword (16-bit value)
w - word (32-bit value)
g - giant word (64-bit value)
Length
Specifies the number of elements that will be displayed by this command.

** eg:
(gdb) x/32s argv[0]
0x7fffffffe4c5: "/root/lzy/lua/lua-5.3.5/src/lua"
0x7fffffffe4e5: "hello.lua"
0x7fffffffe4ef: "DISPLAY=localhost:10.0"
0x7fffffffe506: "GRADLE_HOME=/opt/gradle/latest"
0x7fffffffe525: "HISTCONTROL=ignoredups"
0x7fffffffe53c: "HISTSIZE=50000"
0x7fffffffe54b: "HOME=/root"
0x7fffffffe556: "HOSTNAME=v10"
0x7fffffffe563: "JAVA_HOME=/opt/jdk1.8.0_181"
0x7fffffffe57f: "JRE_HOME=/opt/jdk1.8.0_181/jre"
0x7fffffffe59e: "LANG=en_US.UTF-8"
0x7fffffffe5af: "LC_CTYPE=en_US.UTF-8"
0x7fffffffe5c4: "LESS=-R"
...
* (gdb) ptype i
type = int
(gdb) ptype &i
type = int *
(gdb) ptype main
type = int (void)
* show current statement
(gdb) frame
#0  pmain (L=0x644018) at lua.c:558
558       int args = collectargs(argv, &script);
* show structure's values
print *variable
If you do that it will display the value of that variable in GDB.
You also have an option to display the struct in an indentation and new line:

$1 = {
next = 0x0,
flags = {
sweet = 1,
sour = 1
},
meat = 0x54 "Pork"
}
For that you need to set the pretty print:

set print pretty on
If you want to print an array of values you do like so:

print *array@len
* step out : fin
finish: Continue running until just after function in the selected stack frame
returns. Print the returned value (if any). This command can be abbreviated as fin.
