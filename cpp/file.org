* write to file 中文乱码  :encoding:
std::ofstream file("output", std::ios::binary);  // def mode is text if not set to binary
- std::ofstream本身不做编码转换：C++标准库的文件流类（如 std::ofstream）仅仅按字节写入/读取数据，对编码毫无感知。编码相关动作（比如ASCII、UTF-8、GBK等）全靠你写入时的内容本身决定。
- std::ios::binary 保证不发生“回车换行翻译”等行为。
- 你可以往文件写入任何内容，包括结构体、图片、乱码皆可，编码完全看你自己。

 #+begin_src cpp
// Writing text
std::ofstream tfile("file.txt");
tfile << "Hello\n";  // On Windows, the file may contain "Hello\r\n"

// Writing binary
std::ofstream bfile("file.bin", std::ios::binary);
bfile << "Hello\n"; // The file contains bytes: H e l l o \n (no translation)
 #+end_src

outfile << "中文abc";
即使文件以二进制模式打开，<< 写入的字符串 "中文abc" 是根据你当前源码文件的编码保存的。如果你的源码就是 UTF-8 编码，并且整个操作系统和编辑器都能正确处理 UTF-8，那可能没事；但在很多情况下，尤其是 Windows 下，多半会是 GBK 或 ANSI，程序写入的并不是 UTF-8 字节流，查看容易乱码。

标准解决办法是不要用 <<，而用 write()，并明确保证写入的是 UTF-8 字节流：

推荐做法举例
1. 源码保存为 UTF-8
假如你用的是 C++11 或更新，推荐这样：

#+begin_src cpp
#include <fstream>
#include <string>

int main() {
    std::ofstream outfile("output.bin", std::ios::binary);

    // char* way
    // u8 字符串字面量自动是 UTF-8 编码：
    const char* utf8_str = u8"中文";
    // 直接写入 UTF-8 字符流
    outfile.write(utf8_str, std::strlen(utf8_str));

    // string way
    std::string data = u8"中文abc";    // u8前缀保证字符串是UTF-8

    outfile.write(data.data(), data.size());  // 按字节写入

    outfile.close();
    return 0;
}
#+end_src

这样 data 一定是 UTF-8 字节流，直接写入绝不会乱码。
1. 不用 <<，而是 write()
<< 只适合写纯英文、或者你所有环境都保证编码一致的场景。写二进制时，用 write()：

    std::ofstream outfile("output.bin", std::ios::binary);
    std::string data = u8"中文abc";    // u8前缀保证字符串是UTF-8
    outfile.write(data.data(), data.size());
3. 验证
用十六进制编辑器或支持 UTF-8 的文本编辑器打开 output.bin，会正确显示 “中文abc”。

总结
用 write() 按字节方式写入 UTF-8（std::string u8前缀）数据，保证结果不会乱码！
用 << 不适合写 Unicode 中文到二进制，容易受编译器、系统编码影响出现乱码。

** write
// write function expects a pointer to char (a byte buffer), so we reinterpret the address as a pointer to a sequence of bytes starting at value
    std::ofstream file("output.bin", std::ios::binary);
    int value = 123456;
    file.write(reinterpret_cast<char*>(&value), sizeof(value));

** rdbuf gets the underlying stream buffer for advanced manipulation
    std::ifstream in("input.txt");
    std::ofstream out("output.txt");
    out << in.rdbuf();  // Copy all content from 'in' to 'out'
* std::filesystem::path::lexically_normal()
 It simplifies things like redundant ., .., and extra slashes.
| a/b/./c/../d/    | a/b/d/   |
| /foo//bar/../baz | /foo/baz |
| ../a/../b        | ../b     |
| ./foo/bar        | foo/bar  |

* 斜杆转换为反斜杠
#+begin_src cpp
#include <filesystem>
namespace fs = std::filesystem;

    std::wstring path = L"c:/book/Ab";
    // 使用 std::filesystem::path 进行转换
    fs::path p(path);
    p.make_preferred(); // 将斜杠转换为当前系统的首选格式（Windows 上是反斜杠）
    std::wstring converted_path = p.wstring();
#+end_src

* filesystem 文件路径操作  filepath
#include <filesystem>
#include <iostream>
#include <iterator>

int main() {
    std::filesystem::path p("/root/work/script/pass20250602/RG-三层路由域-BGP-BGP多径路由-GN-TP/RG-三层路由域-BGP-IPv6-VRF-UCMP-93266-GN-001.txt");

    auto begin = p.begin();
    // 0:/, 1:root, 2:work, 3:script, 4:pass20250602, 5:RG-..., etc.
    std::advance(begin, 4); // Move to 4th part (pass20250602)
    auto end = begin;
    std::advance(end, 2);   // Move 2 steps further (so subpath is [4, 6))

    std::filesystem::path subpath;
    for (auto it = begin; it != end; ++it)
        subpath /= *it;
    std::cout << subpath.string() << '\n'; // Prints: pass20250602/RG-三层路由域-BGP-BGP多径路由-GN-TP
}


#include <filesystem>
#include <iostream>
#include <vector>

int main() {
    std::filesystem::path p("/root/work/script/pass20250602/RG-三层路由域-BGP-BGP多径路由-GN-TP/RG-三层路由域-BGP-IPv6-VRF-UCMP-93266-GN-001.txt");

    std::vector<std::filesystem::path> parts;
    for (const auto& part : p) {
        if (!part.empty()) parts.push_back(part);
    }
    // 0:/, 1:root, 2:work, 3:script, 4:pass..., 5:RG-三层...
    std::filesystem::path subpath = parts[4] / parts[5];
    std::cout << subpath.string() << '\n'; // Outputs desired result
}
